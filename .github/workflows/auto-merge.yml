name: Auto Merger 2 (Sequential wait)

on:
  push:
    branches:
      - dev

permissions:
  contents: write
  actions: read

# ek waqt me sirf 1 cascade
concurrency:
  group: auto-merger
  cancel-in-progress: false

jobs:
  merge_and_wait:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set branch list & workflow name
        id: cfg
        run: |
          echo "branches=f1 f2 f3 f4 f5 f6 f7" >> $GITHUB_OUTPUT
          echo "workflow=Serverless Build and Deploy" >> $GITHUB_OUTPUT

      - name: Merge & Wait loop (short)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const branches = `${{ steps.cfg.outputs.branches }}`.split(' ').filter(Boolean);
            const WF_NAME = `${{ steps.cfg.outputs.workflow }}`;

            async function mergeDevInto(target) {
              try {
                await github.request('POST /repos/{owner}/{repo}/merges', {
                  owner, repo, base: target, head: 'dev',
                  commit_message: `Auto-merge dev → ${target}`
                });
                core.info(`Merged dev → ${target} (or already up-to-date).`);
              } catch (e) {
                if (e.status === 409) {
                  core.setFailed(`Merge conflict while merging dev → ${target}.`);
                } else {
                  core.setFailed(`Merge API error for ${target}: ${e.message}`);
                }
                throw e;
              }
            }

            async function latestRunFor(branch) {
              const { data } = await github.rest.actions.listWorkflowRunsForRepo({
                owner, repo, branch, per_page: 20
              });
              // repo-level runs; filter by workflow name
              return (data.workflow_runs || []).find(r => r.name === WF_NAME);
            }

            async function waitForGreen(branch) {
              const deadline = Date.now() + 90 * 60 * 1000; // 90 min
              let lastId = 0;

              while (Date.now() < deadline) {
                const run = await latestRunFor(branch);
                if (!run) {
                  core.info(`[${branch}] No run yet. Waiting...`);
                } else {
                  if (run.id !== lastId) {
                    core.info(`[${branch}] Run #${run.id} status=${run.status} conclusion=${run.conclusion}`);
                    lastId = run.id;
                  }
                  if (run.status === 'completed') {
                    if (run.conclusion === 'success') {
                      core.info(`[${branch}] ✅ Build success.`);
                      return;
                    }
                    core.setFailed(`[${branch}] ❌ Build failed (conclusion=${run.conclusion}).`);
                    throw new Error('Build failed');
                  }
                }
                await new Promise(r => setTimeout(r, 15000));
              }
              core.setFailed(`[${branch}] ⏰ Timeout waiting for Build-and-Deploy success.`);
              throw new Error('Timeout');
            }

            for (const br of branches) {
              core.startGroup(`➡️ dev → ${br}`);
              await mergeDevInto(br);
              core.info(`Waiting for "${WF_NAME}" on ${br}...`);
              await waitForGreen(br);
              core.endGroup();
            }
